# WARNING - Generated by {fusen} from dev/build_envs.Rmd: do not edit by hand

#' find_rev Find the right Nix revision
#' @param r_version Character. R version to look for, for example, "4.2.0". If a nixpkgs revision is provided instead, this gets returned.
#' @return A character. The Nix revision to use
#' @export
#'
#' @examples
#' find_rev("4.2.0")
find_rev <- function(r_version){

  stopifnot("r_version has to be a character." = is.character(r_version))

  if(r_version == "current"){
    return(get_current())
  } else if(nchar(r_version) == 40){
    return(r_version)
  } else {

  temp <- new.env(parent = emptyenv())

  data(list = "r_nix_revs",
       package = "rix",
       envir = temp)

  get("r_nix_revs", envir = temp)

  output <- r_nix_revs$revision[r_nix_revs$version == r_version]

  stopifnot("Error: the provided R version is likely wrong. Please check that you provided a correct R version. You can list available versions using `available_r()`" = !identical(character(0), output))

    output
}

}


#' List available R versions from Nixpkgs
#' @return A character vector containing the available R versions.
#' @export
#'
#' @examples
#' available_r()
available_r <- function(){

  temp <- new.env(parent = emptyenv())

  data(list = "r_nix_revs",
       package = "rix",
       envir = temp)

  get("r_nix_revs", envir = temp)

  c("current", r_nix_revs$version)
}


#' get_current Get the current R version and packages
#' @return A character. The commit hash of the latest nixpkgs-unstable revision
#' @importFrom httr content GET stop_for_status
#' @importFrom jsonlite fromJSON
#' @export
#'
get_current <- function() {
  api_url <- "https://api.github.com/repos/NixOS/nixpkgs/commits?sha=nixpkgs-unstable"

  tryCatch({
    response <- httr::GET(url = api_url)
    httr::stop_for_status(response)
    commit_data <- jsonlite::fromJSON(httr::content(response, "text"))
    latest_commit <- commit_data$sha[1]
    return(latest_commit)
  }, error = function(e) {
    cat("Error:", e$message, "\n")
    return(NULL)
  })
}

#' get_sri_hash_deps Get the SRI hash of the NAR serialization of a Github repo
#' @param repo_url A character. The URL to the package's Github repository or to the `.tar.gz` package hosted on CRAN.
#' @param branch_name A character. The branch of interest, NULL for archived CRAN packages.
#' @param commit A character. The commit hash of interest, for reproducibility's sake, NULL for archived CRAN packages.
#' @return The SRI hash as a character
#' @noRd
get_sri_hash_deps <- function(repo_url, branch_name, commit){
  result <- httr::GET(paste0("http://git2nixsha.dev:1506/hash?repo_url=",
                             repo_url,
                             "&branchName=",
                             branch_name,
                             "&commit=",
                             commit))

  if(httr::http_error(result)){
    stop(paste0("Error in pulling URL: ", repo_url, ". If it's a Github repo, check the url, branch name and commit. Are these correct? If it's an archived CRAN package, check the name of the package and the version number."))
  }


  lapply(httr::content(result), unlist)

}

#' fetchgit Downloads and installs a package hosted of Git
#' @param git_pkg A list of four elements: "package_name", the name of the package, "repo_url", the repository's url, "branch_name", the name of the branch containing the code to download and "commit", the commit hash of interest. 
#' @return A character. The Nix definition to download and build the R package from Github.
#' @noRd
fetchgit <- function(git_pkg){

  package_name <- git_pkg$package_name
  repo_url <- git_pkg$repo_url
  branch_name <- git_pkg$branch_name
  commit <- git_pkg$commit

  output <- get_sri_hash_deps(repo_url, branch_name, commit)
  sri_hash <- output$sri_hash
  imports <- output$deps

  sprintf('(pkgs.rPackages.buildRPackage {
    name = \"%s\";
    src = pkgs.fetchgit {
      url = \"%s\";
      branchName = \"%s\";
      rev = \"%s\";
      sha256 = \"%s\";
    };
    propagatedBuildInputs = builtins.attrValues {
      inherit (pkgs.rPackages) %s;
    };
  })',
  package_name,
  repo_url,
  branch_name,
  commit,
  sri_hash,
  imports
)

}


#' fetchzip Downloads and installs an archived CRAN package
#' @param archive_pkg A character of the form "dplyr@0.80"
#' @return A character. The Nix definition to download and build the R package from CRAN.
#' @noRd
fetchzip <- function(archive_pkg, sri_hash = NULL){

  pkgs <- unlist(strsplit(archive_pkg, split = "@"))

  cran_archive_link <- paste0(
    "https://cran.r-project.org/src/contrib/Archive/",
    pkgs[1], "/",
    paste0(pkgs[1], "_", pkgs[2]),
    ".tar.gz")

  package_name <- pkgs[1]
  repo_url <- cran_archive_link

  if(is.null(sri_hash)){
    output <- get_sri_hash_deps(repo_url, branch_name = NULL, commit = NULL)
    sri_hash <- output$sri_hash
    imports <- output$deps
  } else {
    sri_hash <- sri_hash
    imports <- NULL
  }

  sprintf('(pkgs.rPackages.buildRPackage {
    name = \"%s\";
    src = pkgs.fetchzip {
      url = \"%s\";
      sha256 = \"%s\";
    };
    propagatedBuildInputs = builtins.attrValues {
      inherit (pkgs.rPackages) %s;
    };
  })',
  package_name,
  repo_url,
  sri_hash,
  imports
)
}



#' fetchgits Downloads and installs a packages hosted of Git. Wraps `fetchgit()` to handle multiple packages
#' @param git_pkgs A list of four elements: "package_name", the name of the package, "repo_url", the repository's url, "branch_name", the name of the branch containing the code to download and "commit", the commit hash of interest. This argument can also be a list of lists of these four elements.
#' @return A character. The Nix definition to download and build the R package from Github.
#' @noRd
fetchgits <- function(git_pkgs){

  if(!all(sapply(git_pkgs, is.list))){
    fetchgit(git_pkgs)
  } else if(all(sapply(git_pkgs, is.list))){
    paste(lapply(git_pkgs, fetchgit), collapse = "\n")
  } else {
    stop("There is something wrong with the input. Make sure it is either a list of four elements 'package_name', 'repo_url', 'branch_name' and 'commit' or a list of lists with these four elements")
  }

}

#' fetchzips Downloads and installs packages hosted in the CRAN archives. Wraps `fetchzip()` to handle multiple packages.
#' @param archive_pkgs A character, or an atomic vector of characters.
#' @return A character. The Nix definition to download and build the R package from the CRAN archives.
#' @noRd
fetchzips <- function(archive_pkgs){

  if(is.null(archive_pkgs)){
    "" #Empty character in case the user doesn't need any packages from the CRAN archives.
  } else if(length(archive_pkgs) == 1){
    fetchzip(archive_pkgs)
  } else if(length(archive_pkgs) > 1){
    paste(lapply(archive_pkgs, fetchzip), collapse = "\n")
  } else {
    stop("There is something wrong with the input. Make sure it is either a sinle package name, or an atomic vector of package names, for example c('dplyr@0.8.0', 'tidyr@1.0.0').")
  }

}

#' fetchpkgs Downloads and installs packages hosted in the CRAN archives or Github.
#' @param git_pkgs A list of four elements: "package_name", the name of the package, "repo_url", the repository's url, "branch_name", the name of the branch containing the code to download and "commit", the commit hash of interest. This argument can also be a list of lists of these four elements.
#' @param archive_pkgs A character, or an atomic vector of characters.
#' @return A character. The Nix definition to download and build the R package from the CRAN archives.
#' @noRd
fetchpkgs  <- function(git_pkgs, archive_pkgs){
  paste(fetchgits(git_pkgs),
        fetchzips(archive_pkgs),
        collapse = "\n")
}


#' rix Generates a Nix expression that builds a reproducible development environment
#' @return Nothing, this function only has the side-effect of writing a file
#'   called "default.nix" in the working directory. This file contains the
#'   expression to build a reproducible environment using the Nix package
#'   manager.
#' @param r_ver Character, defaults to "current". The required R version. To use the current version
#'   of R, use "current". You can check which R versions are available using `available_r`.
#'   If a nixpkgs revision is provided instead, this gets returned.
#' @param r_pkgs Vector of characters. List the required R packages for your
#'   analysis here.
#' @param system_pkgs Vector of characters. List further software you wish to install that
#'   are not R packages such as command line applications for example.
#' @param git_pkgs List. A list of packages to install from Git. See details for more information.
#' @param ide Character, defaults to "other". If you wish to use RStudio to work
#'   interactively use "rstudio" or "code" for Visual Studio Code. For other editors,
#'   use "other". This has been tested with RStudio, VS Code and Emacs. If other
#'   editors don't work, please open an issue.
#' @param project_path Character, defaults to the current working directory. Where to write
#'   `default.nix`, for example "/home/path/to/project".
#'   The file will thus be written to the file "/home/path/to/project/default.nix".
#' @param overwrite Logical, defaults to FALSE. If TRUE, overwrite the `default.nix`
#'   file in the specified path.
#' @param print Logical, defaults to FALSE. If TRUE, print `default.nix` to console.
#' @details This function will write a `default.nix` in the chosen path. Using
#'   the Nix package manager, it is then possible to build a reproducible
#'   development environment using the `nix-build` command in the path. This
#'   environment will contain the chosen version of R and packages, and will not
#'   interfere with any other installed version (via Nix or not) on your
#'   machine. Every dependency, including both R package dependencies but also
#'   system dependencies like compilers will get installed as well in that
#'   environment. If you use RStudio for interactive work, then set the
#'   `rstudio` parameter to `TRUE`. If you use another IDE (for example Emacs or
#'   Visual Studio Code), you do not need to add it to the `default.nix` file,
#'   you can simply use the version that is installed on your computer. Once you built
#'   the environment using `nix-build`, you can drop into an interactive session
#'   using `nix-shell`. See the "Building reproducible development environments with rix"
#'   vignette for detailled instructions.
#'   Packages to install from Github must be provided in a list of 4 elements:
#'   "package_name", "repo_url", "branch_name" and "commit".
#'   This argument can also be a list of lists of these 4 elements. It is also possible to install old versions
#'   of packages by specifying a version. For example, to install the latest
#'   version of `{AER}` but an old version of `{ggplot2}`, you could
#'   write: `r_pkgs = c("AER", "ggplot2@2.2.1")`. Note
#'   however that doing this could result in dependency hell, because an older
#'   version of a package might need older versions of its dependencies, but other
#'   packages might need more recent versions of the same dependencies. If instead you
#'   want to use an environment as it would have looked at the time of `{ggplot2}`'s
#'   version 2.2.1 release, then use the Nix revision closest to that date, by setting
#'   `r_ver = "3.1.0"`, which was the version of R current at the time. This
#'   ensures that Nix builds a completely coherent environment.
#' @export
rix <- function(r_ver = "current",
                 r_pkgs,
                 system_pkgs = NULL,
                 git_pkgs = NULL,
                 ide = "other",
                 project_path = ".",
                 overwrite = FALSE,
                 print = FALSE){

  stopifnot("'ide' has to be one of 'other', 'rstudio' or 'code'" = (ide %in% c("other", "rstudio", "code")))

  project_path <- if(project_path == "."){
     "default.nix"
  } else {
    paste0(project_path, "/default.nix")
  }

  # Generate the correct text for the header depending on wether
  # an R version or a Nix revision is supplied to `r_ver`
  if(nchar(r_ver) > 20){
    r_ver_text <- paste0("as it was as of nixpkgs revision: ", r_ver)
  } else {
    r_ver_text <- paste0("version ", r_ver)
  }

  # Find the Nix revision to use
  nix_revision <- find_rev(r_ver)

  project_path <- file.path(project_path)

  rix_call <- match.call()

  generate_rix_call <- function(rix_call, nix_revision){

    rix_call$r_ver <- nix_revision

    rix_call <- paste0("# >", deparse1(rix_call))

    gsub(",", ",\n#  >", rix_call)
  }

  # Get teh current rix version
  rix_version <- utils::packageVersion("rix")

  generate_header <- function(rix_version,
                              nix_revision,
                              r_ver_text,
                              rix_call){

    sprintf('# This file was generated by the {rix} R package v%s on %s
# with following call:
%s
# It uses nixpkgs\' revision %s for reproducibility purposes
# which will install R %s
# Report any issues to https://github.com/b-rodrigues/rix
let
 pkgs = import (fetchTarball "https://github.com/NixOS/nixpkgs/archive/%s.tar.gz") {};
',
  rix_version,
  Sys.Date(),
  generate_rix_call(rix_call, nix_revision),
  nix_revision,
  r_ver_text,
  nix_revision
  )
 }

  # Now we need to generate all the different sets of packages
  # to install. Let's start by the CRAN packages, current
  # and archived. The function below builds the strings.
  get_rPackages <- function(r_pkgs){

    # in case users pass something like c("dplyr", "tidyr@1.0.0")
    # r_pkgs will be "dplyr" only
    # and "tidyr@1.0.0" needs to be handle by fetchzips
    r_and_archive_pkgs <- detect_versions(r_pkgs)

    # overwrite r_pkgs
    r_pkgs <- r_and_archive_pkgs$cran_packages

    # get archive_pkgs
    archive_pkgs <- r_and_archive_pkgs$archive_packages

    r_pkgs <- if(ide == "code"){
                c(r_pkgs, "languageserver")
              } else {
                r_pkgs
              }

    rPackages <- paste(r_pkgs, collapse = ' ')

    rPackages <- gsub('\\.', '_', rPackages)

    list("rPackages" = rPackages,
         "archive_pkgs" = archive_pkgs)

  }

  # Get the two lists. One list is current CRAN packages
  # the other is archived CRAN packages.
  cran_pkgs <- get_rPackages(r_pkgs)

  # we need to know if the user wants R packages

  flag_rpkgs <- if(is.null(cran_pkgs$rPackages) | cran_pkgs$rPackages == ""){
                  ""
                } else {
                  "rpkgs"
                }

  # generate_* function generate the actual Nix code
  generate_rpkgs <- function(rPackages){
    if(flag_rpkgs == ""){
      NULL
    } else {
      sprintf('rpkgs = builtins.attrValues {
  inherit (pkgs.rPackages) %s;
};
',
rPackages)
    }
  }

  # system packages
  get_system_pkgs <- function(system_pkgs){
    paste(system_pkgs, collapse = ' ')
  }

  flag_git_archive <- if(!is.null(cran_pkgs$archive) | !is.null(git_pkgs)){
                        "git_archive_pkgs"
                      } else {
                        ""
                      }

  generate_git_archived_packages <- function(git_pkgs, archive_pkgs){
    if(flag_git_archive == ""){
      NULL
    } else {
    sprintf('git_archive_pkgs = [%s];\n',
            fetchpkgs(git_pkgs, archive_pkgs)
            )
    }
  }


  # `R` needs to be added. If we were using the rWrapper
  # this wouldn't be needed, but we're not so we need
  # to add it.
  generate_system_pkgs <- function(system_pkgs){
    sprintf('system_packages = builtins.attrValues {
  inherit (pkgs) R %s;
};
',
get_system_pkgs(system_pkgs))
  }

  generate_rstudio_pkgs <- function(ide, flag_git_archive, flag_rpkgs){
    if(ide == "rstudio"){
      sprintf('rstudio_pkgs = pkgs.rstudioWrapper.override {
  packages = [ %s %s ];
};
',
flag_git_archive,
flag_rpkgs
)
    } else {
      NULL
    }
  }

  flag_rstudio <- if(ide == "rstudio"){
                        "rstudio_pkgs"
                      } else {
                        ""
                      }

  # Generate the shell
  # we should add arguments to this function
  # for example, give the option to have a shellhook etc
  # for now, keep the shellhook R --vanilla
  generate_shell <- function(flag_git_archive, flag_rpkgs){
    sprintf('in
  pkgs.mkShell {
    buildInputs = [ %s %s system_packages %s ];
    shellHook = "R --vanilla";
  }',
  flag_git_archive,
  flag_rpkgs,
  flag_rstudio
  )

  }

  # Generate default.nix file
  default.nix <- paste(
    generate_header(rix_version,
                    nix_revision,
                    r_ver_text,
                    rix_call),
    generate_rpkgs(cran_pkgs$rPackages),
    generate_git_archived_packages(git_pkgs, cran_pkgs$archive_pkgs),
    generate_system_pkgs(system_pkgs),
    generate_rstudio_pkgs(ide, flag_git_archive, flag_rpkgs),
    generate_shell(flag_git_archive, flag_rpkgs),
    collapse = "\n"
    )

  default.nix <- readLines(textConnection(default.nix))

  if(print){
    cat(default.nix, sep = "\n")
  }

  if(!file.exists(project_path) || overwrite){
    writeLines(default.nix, project_path)
  } else {
    stop(paste0("File exists at ", project_path, ". Set `overwrite == TRUE` to overwrite."))
  }



}



#' Invoke shell command `nix-build` from an R session
#' @param project_path Path to the folder where the `default.nix` file resides. 
#' The default is `"."`, which is the working directory in the current R
#' session.
#' @param exec_mode Either `"blocking"` (default) or `"non-blocking`. This
#' will either block the R session while the `nix-build` shell command is
#' executed, or run `nix-build` in the background ("non-blocking").
#' @return integer of the process ID (PID) of `nix-build` shell command
#' launched, if `nix_build()` call is assigned to an R object. Otherwise, it 
#' will be returned invisibly.
#' @export
nix_build <- function(project_path = ".",
                      exec_mode = c("blocking", "non-blocking")) {
  has_nix_build <- nix_build_installed() # TRUE if yes, FALSE if no
  nix_file <- file.path(project_path, "default.nix")
  
  stopifnot(
    "`project_path` must be character of length 1." =
      is.character(project_path) && length(project_path) == 1L,
    "`project_path` has no `default.nix` file. Use one that contains `default.nix`" =
      file.exists(nix_file),
    "`nix-build` not available. To install, we suggest you follow https://zero-to-nix.com/start/install ." =
      isTRUE(has_nix_build)
  )
  exec_mode <- match.arg(exec_mode)
  
  cat(paste0("Launching `nix-build`", " in ", exec_mode, " mode\n"))
  
  proc <- switch(exec_mode,
    "blocking" = sys::exec_internal("nix-build", nix_file),
    "non-blocking" = sys::exec_background("nix-build", nix_file),
    stop('invalid `exec_mode`. Either use "blocking" or "non-blocking"')
  )
  
  if (exec_mode == "non-blocking") {
    cat(paste0("\n==> Process ID (PID) is ", proc, "."))
    cat("\n==> Receiving stdout and stderr streams...\n")
    status <- sys::exec_status(proc, wait = TRUE)
    if (status == 0L) {
      cat("\n==> `nix-build` succeeded!")
    }
  }
  
  if (exec_mode == "blocking") {
    status <- proc$status
    if (status == 0L) {
      cat(paste0("\n==> ", sys::as_text(proc$stdout)))
      cat("\n==> `nix-build` succeeded!")
    } else {
      msg <- nix_build_exit_msg()
      cat(paste0("`nix-build` failed with ", msg))
    }
  }
  
  # todo (?): clean zombies for background/non-blocking mode
  # rm(pid)
  
  return(invisible(proc))
}

#' @noRd
nix_build_installed <- function() {
  exit_code <- system2("command", "-v", "nix-build")
  if (exit_code == 0L) {
    return(invisible(TRUE))
  } else {
    return(invisible(FALSE))
  }
}

#' @noRd
nix_build_exit_msg <- function(x) {
  x_char <- as.character(x)
  
  err_msg <- switch(
    x_char,
    "100" = "generic build failure (100).",
    "101" = "build timeout (101).",
    "102" = "hash mismatch (102).",
    "104" = "not deterministic (104).",
    stop(paste0("general exit code ", x_char, "."))
  )
  
  return(err_msg)
}
