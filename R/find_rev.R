# WARNING - Generated by {fusen} from dev/build_envs.Rmd: do not edit by hand

#' find_rev Find the right Nix revision
#' @param r_version Character. R version to look for, for example, "4.2.0"
#' @return A character. The Nix revision to use
#' @export
#'
#' @examples
#' find_rev("4.2.0")
find_rev <- function(r_version){

  if(r_version == "current"){
    return(get_current())
  } else {

  temp <- new.env(parent = emptyenv())

  data(list = "r_nix_revs",
       package = "rix",
       envir = temp)

  get("r_nix_revs", envir = temp)

  output <- r_nix_revs$revision[r_nix_revs$version == r_version]

  stopifnot("Error: the provided R version is likely wrong. Please check that you provided a correct R version. You can list available versions using `available_r()`" = !identical(character(0), output))

    output
}

}


#' available_r List available R versions
#' @return A character vector containing the available R versrions.
#' @export
#'
#' @examples
#' available_r()
available_r <- function(){

  temp <- new.env(parent = emptyenv())

  data(list = "r_nix_revs",
       package = "rix",
       envir = temp)

  get("r_nix_revs", envir = temp)

  c("current", r_nix_revs$version)

}


#' get_current Get the current R version and packages
#' @return A character. The commit hash of the latest nixpkgs-unstable revision
#' @importFrom httr content GET stop_for_status
#' @importFrom jsonlite fromJSON
#' @export
#'
get_current <- function() {
  api_url <- "https://api.github.com/repos/NixOS/nixpkgs/commits?sha=nixpkgs-unstable"

  tryCatch({
    response <- httr::GET(url = api_url)
    httr::stop_for_status(response)
    commit_data <- jsonlite::fromJSON(httr::content(response, "text"))
    latest_commit <- commit_data$sha[1]
    return(latest_commit)
  }, error = function(e) {
    cat("Error:", e$message, "\n")
    return(NULL)
  })
}

#' get_sri_hash_deps Get the SRI hash of the NAR serialization of a Github repo
#' @param repo_url A character. The URL to the package's Github repository or to the `.tar.gz` package hosted on CRAN.
#' @param branch_name A character. The branch of interest, NULL for archived CRAN packages.
#' @param commit A character. The commit hash of interest, for reproducibility's sake, NULL for archived CRAN packages.
#' @return The SRI hash as a character
#' @noRd
get_sri_hash_deps <- function(repo_url, branch_name, commit){
  result <- httr::GET(paste0("http://git2nixsha.dev:1506/hash?repo_url=",
                             repo_url,
                             "&branchName=",
                             branch_name,
                             "&commit=",
                             commit))

  if(httr::http_error(result)){
    stop(paste0("Error in pulling URL: ", repo_url, ". If it's a Github repo, check the url, branch name and commit. Are these correct? If it's an archived CRAN package, check the name of the package and the version number."))
  }


  lapply(httr::content(result), unlist)

}

#' fetchgit Downloads and installs a package hosted of Git
#' @param git_pkg A list of at least four elements: "package_name", the name of the package, "repo_url", the repository's url, "branch_name", the name of the branch containing the code to download and "commit", the commit hash of interest. A fifth, optional argument called "sri_hash" can be provided, if available. If not, "sri_hash" will be obtained using `get_sri_hash_deps()`
#' @return A character. The Nix definition to download and build the R package from Github.
#' @noRd
fetchgit <- function(git_pkg){

  package_name <- git_pkg$package_name
  repo_url <- git_pkg$repo_url
  branch_name <- git_pkg$branch_name
  commit <- git_pkg$commit
  sri_hash <- git_pkg$sri_hash

  if(is.null(sri_hash)){
    output <- get_sri_hash_deps(repo_url, branch_name, commit)
    sri_hash <- output$sri_hash
    imports <- output$deps
  } else {
    sri_hash <- sri_hash
    imports <- NULL
  }

  sprintf('(buildRPackage {
    name = \"%s\";
    src = fetchgit {
      url = \"%s\";
      branchName = \"%s\";
      rev = \"%s\";
      sha256 = \"%s\";
    };
    propagatedBuildInputs = [
        %s
      ];
  })',
  package_name,
  repo_url,
  branch_name,
  commit,
  sri_hash,
  imports
)

}


#' fetchzip Downloads and installs an archived CRAN package
#' @param archive_pkg A character of the form "dplyr@0.80"
#' @return A character. The Nix definition to download and build the R package from CRAN.
#' @noRd
fetchzip <- function(archive_pkg, sri_hash = NULL){

  pkgs <- unlist(strsplit(archive_pkg, split = "@"))

  cran_archive_link <- paste0(
    "https://cran.r-project.org/src/contrib/Archive/",
    pkgs[1], "/",
    paste0(pkgs[1], "_", pkgs[2]),
    ".tar.gz")

  package_name <- pkgs[1]
  repo_url <- cran_archive_link

  if(is.null(sri_hash)){
    output <- get_sri_hash_deps(repo_url, branch_name = NULL, commit = NULL)
    sri_hash <- output$sri_hash
    imports <- output$deps
  } else {
    sri_hash <- sri_hash
    imports <- NULL
  }

  sprintf('(buildRPackage {
    name = \"%s\";
    src = fetchzip {
      url = \"%s\";
      sha256 = \"%s\";
    };
    propagatedBuildInputs = [
        %s
      ];
  })',
  package_name,
  repo_url,
  sri_hash,
  imports
)
}



#' fetchgits Downloads and installs a packages hosted of Git. Wraps `fetchgit()` to handle multiple packages
#' @param git_pkgs A list of at least four elements: "package_name", the name of the package, "repo_url", the repository's url, "branch_name", the name of the branch containing the code to download and "commit", the commit hash of interest. A fifth, optional argument called "sri_hash" can be provided, if available. If not, "sri_hash" will be obtained using `get_sri_hash_deps()`. This argument can also be a list of lists of these four elements.
#' @return A character. The Nix definition to download and build the R package from Github.
#' @noRd
fetchgits <- function(git_pkgs){

  if(!all(sapply(git_pkgs, is.list))){
    fetchgit(git_pkgs)
  } else if(all(sapply(git_pkgs, is.list))){
    paste(lapply(git_pkgs, fetchgit), collapse = "\n")
  } else {
    stop("There is something wrong with the input. Make sure it is either a list of four elements 'package_name', 'repo_url', 'branch_name' and 'commit' or a list of lists with these four elements")
  }

}

#' fetchzips Downloads and installs packages hosted in the CRAN archives. Wraps `fetchzip()` to handle multiple packages.
#' @param archive_pkgs A character, or an atomic vector of characters.
#' @return A character. The Nix definition to download and build the R package from the CRAN archives.
#' @noRd
fetchzips <- function(archive_pkgs){

  if(is.null(archive_pkgs)){
    "" #Empty character in case the user doesn't need any packages from the CRAN archives.
  } else if(length(archive_pkgs) == 1){
    fetchzip(archive_pkgs)
  } else if(length(archive_pkgs) > 1){
    paste(lapply(archive_pkgs, fetchzip), collapse = "\n")
  } else {
    stop("There is something wrong with the input. Make sure it is either a sinle package name, or an atomic vector of package names, for example c('dplyr@0.8.0', 'tidyr@1.0.0').")
  }

}

#' fetchpkgs Downloads and installs packages hosted in the CRAN archives or Github.
#' @param git_pkgs A list of at least four elements: "package_name", the name of the package, "repo_url", the repository's url, "branch_name", the name of the branch containing the code to download and "commit", the commit hash of interest. A fifth, optional argument called "sri_hash" can be provided, if available. If not, "sri_hash" will be obtained using `get_sri_hash_deps()`. This argument can also be a list of lists of these four elements.
#' @param archive_pkgs A character, or an atomic vector of characters.
#' @return A character. The Nix definition to download and build the R package from the CRAN archives.
#' @noRd
fetchpkgs  <- function(git_pkgs, archive_pkgs){
  paste(fetchgits(git_pkgs),
        fetchzips(archive_pkgs),
        collapse = "\n")
}


#' rix Generates a Nix expression that builds a reproducible development environment 
#' @return Nothing, this function only has the side-effect of writing a file
#'   called "default.nix" in the working directory. This file contains the
#'   expression to build a reproducible environment using the Nix package
#'   manager.
#' @param r_ver Character, defaults to "current". The required R version. To use the current version
#'   of R, use "current". You can check which R versions are available using `available_r`.
#' @param r_pkgs Vector of characters. List the required R packages for your
#'   analysis here.
#' @param other_pkgs Vector of characters. List further software you wish to install that
#'   are not R packages such as command line applications for example.
#' @param git_pkgs List. A list of packages to install from Git. See details for more information.
#' @param ide Character, defaults to "other". If you wish to use RStudio to work
#'   interactively use "rstudio", "code" for Visual Studio Code. For other editors,
#'   use "other". This has been tested with RStudio, VS Code and Emacs. If other
#'   editors don't work, please open an issue.
#' @param path Character, defaults to the current working directory. Where to write
#'   `default.nix`, for example "/home/path/to/project".
#'   The file will thus be written to the file "/home/path/to/project/default.nix".
#' @param overwrite Logical, defaults to FALSE. If TRUE, overwrite the `default.nix`
#'   file in the specified path.
#' @details This function will write a `default.nix` in the chosen path. Using
#'   the Nix package manager, it is then possible to build a reproducible
#'   development environment using the `nix-build` command in the path. This
#'   environment will contain the chosen version of R and packages, and will not
#'   interfere with any other installed version (via Nix or not) on your
#'   machine. Every dependency, including both R package dependencies but also
#'   system dependencies like compilers will get installed as well in that
#'   environment. If you use RStudio for interactive work, then set the
#'   `rstudio` parameter to `TRUE`. If you use another IDE (for example Emacs or
#'   Visual Studio Code), you do not need to add it to the `default.nix` file,
#'   you can simply use the version that is installed on your computer. Once you built
#'   the environment using `nix-build`, you can drop into an interactive session
#'   using `nix-shell`. See the "Building reproducible development environments with rix" 
#'   vignette for detailled instructions.
#'   Packages to install from Github must be provided in a list of 4 elements:
#'   "package_name", "repo_url", "branch_name" and "commit". A fifth, optional
#'   element, "sri_hash" can be provided as well. This argument can also be a list
#'   of lists of these 4 elements. It is also possible to install old versions 
#'   of packages by specifying a version. For example, to install the latest
#'   version of `{AER}` but an old version of `{ggplot2}`, you could provide 
#'   the set `r_pkgs` to: `r_pkgs = c("dplyr", "ggplot2@2.2.1")`. Note
#'   however that doing this could result in dependency hell, because an older 
#'   version of a package might need older versions of its dependencies, but other
#'   packages might need more recent version of the same dependencies. If instead you
#'   want to use an environment as it would have looked at the time of `{ggplot2}`'s
#'   version 2.2.1 release, then use the Nix revision closest to that date, by setting
#'   `r_ver = "3.1.0"`, which was the version of R current at the time. This
#'   ensures that Nix builds a complete coherent environment.
#' @export
rix <- function(r_ver = "current",
                r_pkgs,
                other_pkgs = NULL,
                git_pkgs = NULL,
                ide = "other",
                path = ".",
                overwrite = FALSE){

  stopifnot("'ide' has to be one of 'other', 'rstudio' or 'code'" = (ide %in% c("other", "rstudio", "code")))

  path <- if(path == "."){
     "default.nix"
  } else {
    paste0(path, "/default.nix")
  }

  path <- file.path(path)

  # in case users pass something like c("dplyr", "tidyr@1.0.0")
  # r_pkgs will be "dplyr" only
  # and "tidyr@1.0.0" needs to be handle by fetchzips
  r_and_archive_pkgs <- detect_versions(r_pkgs)

  # overwrite r_pkgs
  r_pkgs <- r_and_archive_pkgs$cran_packages

  # get archive_pkgs
  archive_pkgs <- r_and_archive_pkgs$archive_packages

  r_pkgs <- if(ide == "code"){
            c(r_pkgs, "languageserver")
          } else {
            r_pkgs
          }

  r_packages <- paste(r_pkgs, collapse = ' ')
  other_packages <- paste(other_pkgs, collapse = ' ')

  nixFile <- "
# This file was generated by the {rix} R package on DATE
# It uses nixpkgs' revision NIX_REV for reproducibility purposes
# which will install R version RE_VERSION
# Report any issues to https://github.com/b-rodrigues/rix
    { pkgs ? import (fetchTarball \"https://github.com/NixOS/nixpkgs/archive/NIX_REV.tar.gz\") {} }:

      with pkgs;

      let
      my-r = rWrapper.override {
        packages = with rPackages; [
          PACKAGE_LIST
          GIT_PACKAGES
        ];
      };
OTHER_PACKAGES other-pkgs = [OTHER_PKGS];
USE_RSTUDIO  my-rstudio = rstudioWrapper.override {
USE_RSTUDIO    packages = with rPackages; [
USE_RSTUDIO                      PACKAGE_LIST
USE_RSTUDIO                      RSTUDIO_GITPKGS
USE_RSTUDIO        ];
USE_RSTUDIO};
      in
      mkShell {
        LOCALE_ARCHIVE = \"${glibcLocales}/lib/locale/locale-archive\";
        buildInputs = [
          my-r
         USE_RSTUDIO my-rstudio
         OTHER_PACKAGES other-pkgs
          ];
      }"

  nixFile <- gsub('NIX_REV', find_rev(r_ver) , nixFile)
  nixFile <- gsub('RE_VERSION', r_ver , nixFile)
  nixFile <- gsub('DATE', date(), nixFile)

  nixFile <- gsub('USE_RSTUDIO',
                  ifelse(!is.null(ide) & ide == "rstudio", '', 'TO_DELETE'),
                  nixFile)

  nixFile <- gsub('RSTUDIO_GITPKGS',
                  ifelse(!is.null(ide) & ide == "rstudio", 'GIT_PACKAGES', 'RSTUDIO_GITPKGS'),
                  nixFile)

  r_packages <- gsub('\\.', '_', r_packages)
  nixFile <- gsub('PACKAGE_LIST', r_packages, nixFile)

  nixFile <- gsub('OTHER_PKGS', other_packages, nixFile)
  nixFile <- gsub('OTHER_PACKAGES',
                  ifelse(!is.null(other_pkgs), '', 'TO_DELETE'),
                  nixFile)

  # also handles CRAN archive packages through fetchpkgs
  # if both git_pkgs and archive_pkgs are NULL, the empty string gets returned
  nixFile <- gsub('GIT_PACKAGES', fetchpkgs(git_pkgs, archive_pkgs), nixFile)

  nixFile <- readLines(textConnection(nixFile))

  nixFile <- grep('TO_DELETE', nixFile, invert = TRUE, value = TRUE)

  if(!file.exists(path) || overwrite){
    writeLines(nixFile, path)
  } else {
    stop(paste0("File exists at ", path, ". Set `overwrite == TRUE` to overwrite."))
  }

}


#' Invoke shell command `nix-build` from an R session
#' @param nix_file File path to the `default.nix` file. The default is
#' a `default.nix` file in the current working directory of the current R
#' session.
#' @param exec_mode Either `"blocking"` (default) or `"non-blocking`. This
#' will either block the R session while the `nix-build` shell command is
#' executed, or run `nix-build` in the background ("non-blocking").
#' @return integer of the process ID (PID) of `nix-build` shell command
#' launched, if `nix_build()` call is assigned to an R object. Otherwise, it 
#' will be returned as "invisible".
#' @export
nix_build <- function(nix_file = file.path("default.nix"),
                      exec_mode = c("blocking", "non-blocking")) {
  stopifnot(
    "Argument `nix_file` must be character of length 1." =
      is.character(nix_file) && length(nix_file) == 1L,
    "`nix_file` does not exist. Please use a valid path." =
      file.exists(nix_file)
  )
  exec_mode <- match.arg(exec_mode)

  cat(paste0("Launching `nix-build`", " in ", exec_mode, " mode ===> "))
  
  pid <- switch(exec_mode,
    "blocking" = sys::exec_internal("nix-build", nix_file),
    "non-blocking" = sys::exec_background("nix-build", nix_file),
    stop('invalid `exec_mode`. Either use "blocking" or "non-blocking"')
  )
  
  if (exec_mode == "non-blocking") cat(paste0("Process ID (PID) is ", pid, "."))
  
  # clean zombies for background/non-blocking mode
  # rm(pid)
  
  return(invisible(pid))
}
