# WARNING - Generated by {fusen} from dev/build_envs.Rmd: do not edit by hand

#' find_rev Find the right Nix revision
#' @param r_version Character. R version to look for, for example, "4.2.0". If a nixpkgs revision is provided instead, this gets returned.
#' @return A character. The Nix revision to use
#'
#' @examples
#' find_rev("4.2.0")
#' @noRd
find_rev <- function(r_version) {

  stopifnot("r_version has to be a character." = is.character(r_version))

  if(r_version == "latest"){
    return(get_latest())
  } else if(nchar(r_version) == 40){
    return(r_version)
  } else {

  temp <- new.env(parent = emptyenv())

  data(list = "r_nix_revs",
       package = "rix",
       envir = temp)

  get("r_nix_revs", envir = temp)

  output <- r_nix_revs$revision[r_nix_revs$version == r_version]

  stopifnot("Error: the provided R version is likely wrong. Please check that you provided a correct R version. You can list available versions using `available_r()`" = !identical(character(0), output))

    output
}

}


#' List available R versions from Nixpkgs
#' @return A character vector containing the available R versions.
#' @export
#'
#' @examples
#' available_r()
available_r <- function(){

  temp <- new.env(parent = emptyenv())

  data(list = "r_nix_revs",
       package = "rix",
       envir = temp)

  get("r_nix_revs", envir = temp)

  c("latest", r_nix_revs$version)
}


#' get_latest Get the latest R version and packages
#' @return A character. The commit hash of the latest nixpkgs-unstable revision
#' @importFrom httr content GET stop_for_status
#' @importFrom jsonlite fromJSON
#'
#' @noRd
get_latest <- function() {
  api_url <- "https://api.github.com/repos/NixOS/nixpkgs/commits?sha=nixpkgs-unstable"

  tryCatch({
    response <- httr::GET(url = api_url)
    httr::stop_for_status(response)
    commit_data <- jsonlite::fromJSON(httr::content(response, "text"))
    latest_commit <- commit_data$sha[1]
    return(latest_commit)
  }, error = function(e) {
    cat("Error:", e$message, "\n")
    return(NULL)
  })
}

#' get_sri_hash_deps Get the SRI hash of the NAR serialization of a Github repo
#' @param repo_url A character. The URL to the package's Github repository or to the `.tar.gz` package hosted on CRAN.
#' @param branch_name A character. The branch of interest, NULL for archived CRAN packages.
#' @param commit A character. The commit hash of interest, for reproducibility's sake, NULL for archived CRAN packages.
#' @return The SRI hash as a character
#' @noRd
get_sri_hash_deps <- function(repo_url, branch_name, commit){
  result <- httr::GET(paste0("http://git2nixsha.dev:1506/hash?repo_url=",
                             repo_url,
                             "&branchName=",
                             branch_name,
                             "&commit=",
                             commit))

  if(httr::http_error(result)){
    stop(paste0("Error in pulling URL: ", repo_url, ". If it's a Github repo, check the url, branch name and commit. Are these correct? If it's an archived CRAN package, check the name of the package and the version number."))
  }


  lapply(httr::content(result), unlist)

}

#' fetchgit Downloads and installs a package hosted of Git
#' @param git_pkg A list of four elements: "package_name", the name of the package, "repo_url", the repository's url, "branch_name", the name of the branch containing the code to download and "commit", the commit hash of interest. 
#' @return A character. The Nix definition to download and build the R package from Github.
#' @noRd
fetchgit <- function(git_pkg){

  package_name <- git_pkg$package_name
  repo_url <- git_pkg$repo_url
  branch_name <- git_pkg$branch_name
  commit <- git_pkg$commit

  output <- get_sri_hash_deps(repo_url, branch_name, commit)
  sri_hash <- output$sri_hash
  imports <- output$deps

  sprintf('(pkgs.rPackages.buildRPackage {
    name = \"%s\";
    src = pkgs.fetchgit {
      url = \"%s\";
      branchName = \"%s\";
      rev = \"%s\";
      sha256 = \"%s\";
    };
    propagatedBuildInputs = builtins.attrValues {
      inherit (pkgs.rPackages) %s;
    };
  })',
  package_name,
  repo_url,
  branch_name,
  commit,
  sri_hash,
  imports
)

}


#' fetchzip Downloads and installs an archived CRAN package
#' @param archive_pkg A character of the form "dplyr@0.80"
#' @return A character. The Nix definition to download and build the R package from CRAN.
#' @noRd
fetchzip <- function(archive_pkg, sri_hash = NULL){

  pkgs <- unlist(strsplit(archive_pkg, split = "@"))

  cran_archive_link <- paste0(
    "https://cran.r-project.org/src/contrib/Archive/",
    pkgs[1], "/",
    paste0(pkgs[1], "_", pkgs[2]),
    ".tar.gz")

  package_name <- pkgs[1]
  repo_url <- cran_archive_link

  if(is.null(sri_hash)){
    output <- get_sri_hash_deps(repo_url, branch_name = NULL, commit = NULL)
    sri_hash <- output$sri_hash
    imports <- output$deps
  } else {
    sri_hash <- sri_hash
    imports <- NULL
  }

  sprintf('(pkgs.rPackages.buildRPackage {
    name = \"%s\";
    src = pkgs.fetchzip {
      url = \"%s\";
      sha256 = \"%s\";
    };
    propagatedBuildInputs = builtins.attrValues {
      inherit (pkgs.rPackages) %s;
    };
  })',
  package_name,
  repo_url,
  sri_hash,
  imports
)
}



#' fetchgits Downloads and installs a packages hosted of Git. Wraps `fetchgit()` to handle multiple packages
#' @param git_pkgs A list of four elements: "package_name", the name of the package, "repo_url", the repository's url, "branch_name", the name of the branch containing the code to download and "commit", the commit hash of interest. This argument can also be a list of lists of these four elements.
#' @return A character. The Nix definition to download and build the R package from Github.
#' @noRd
fetchgits <- function(git_pkgs){

  if(!all(sapply(git_pkgs, is.list))){
    fetchgit(git_pkgs)
  } else if(all(sapply(git_pkgs, is.list))){
    paste(lapply(git_pkgs, fetchgit), collapse = "\n")
  } else {
    stop("There is something wrong with the input. Make sure it is either a list of four elements 'package_name', 'repo_url', 'branch_name' and 'commit' or a list of lists with these four elements")
  }

}

#' fetchzips Downloads and installs packages hosted in the CRAN archives. Wraps `fetchzip()` to handle multiple packages.
#' @param archive_pkgs A character, or an atomic vector of characters.
#' @return A character. The Nix definition to download and build the R package from the CRAN archives.
#' @noRd
fetchzips <- function(archive_pkgs){

  if(is.null(archive_pkgs)){
    "" #Empty character in case the user doesn't need any packages from the CRAN archives.
  } else if(length(archive_pkgs) == 1){
    fetchzip(archive_pkgs)
  } else if(length(archive_pkgs) > 1){
    paste(lapply(archive_pkgs, fetchzip), collapse = "\n")
  } else {
    stop("There is something wrong with the input. Make sure it is either a sinle package name, or an atomic vector of package names, for example c('dplyr@0.8.0', 'tidyr@1.0.0').")
  }

}

#' fetchpkgs Downloads and installs packages hosted in the CRAN archives or Github.
#' @param git_pkgs A list of four elements: "package_name", the name of the package, "repo_url", the repository's url, "branch_name", the name of the branch containing the code to download and "commit", the commit hash of interest. This argument can also be a list of lists of these four elements.
#' @param archive_pkgs A character, or an atomic vector of characters.
#' @return A character. The Nix definition to download and build the R package from the CRAN archives.
#' @noRd
fetchpkgs  <- function(git_pkgs, archive_pkgs){
  paste(fetchgits(git_pkgs),
        fetchzips(archive_pkgs),
        collapse = "\n")
}


#' rix Generates a Nix expression that builds a reproducible development environment
#' @return Nothing, this function only has the side-effect of writing a file
#'   called "default.nix" in the working directory. This file contains the
#'   expression to build a reproducible environment using the Nix package
#'   manager.
#' @param r_ver Character, defaults to "latest". The required R version, for example "4.0.0".
#'   To use the latest version of R, use "latest", if you need the latest, bleeding edge version
#'   of R and packages, then use "latest". You can check which R versions are available using `available_r`.
#'   For reproducibility purposes, you can also provide a nixpkgs revision.
#' @param r_pkgs Vector of characters. List the required R packages for your
#'   analysis here.
#' @param system_pkgs Vector of characters. List further software you wish to install that
#'   are not R packages such as command line applications for example.
#' @param git_pkgs List. A list of packages to install from Git. See details for more information.
#' @param tex_pkgs Vector of characters. A set of tex packages to install. Use this if you need to compile `.tex` documents, or build PDF documents using Quarto. If you don't know which package to add, start by adding "amsmath". See the Vignette "Authoring LaTeX documents" for more details.
#' @param ide Character, defaults to "other". If you wish to use RStudio to work
#'   interactively use "rstudio" or "code" for Visual Studio Code. For other editors,
#'   use "other". This has been tested with RStudio, VS Code and Emacs. If other
#'   editors don't work, please open an issue.
#' @param project_path Character, defaults to the current working directory. Where to write
#'   `default.nix`, for example "/home/path/to/project".
#'   The file will thus be written to the file "/home/path/to/project/default.nix".
#' @param overwrite Logical, defaults to FALSE. If TRUE, overwrite the `default.nix`
#'   file in the specified path.
#' @param print Logical, defaults to FALSE. If TRUE, print `default.nix` to console.
#' @param shell_hook Character, defaults to `"R --vanilla"`. Commands added to the shell_hook get
#'   executed when the Nix shell starts (via `shellHook`). So by default, using `nix-shell default.nix` will
#'   start R. Set to NULL if you want bash to be started instead.
#' @details This function will write a `default.nix` in the chosen path. Using
#'   the Nix package manager, it is then possible to build a reproducible
#'   development environment using the `nix-build` command in the path. This
#'   environment will contain the chosen version of R and packages, and will not
#'   interfere with any other installed version (via Nix or not) on your
#'   machine. Every dependency, including both R package dependencies but also
#'   system dependencies like compilers will get installed as well in that
#'   environment. If you use RStudio for interactive work, then set the
#'   `rstudio` parameter to `TRUE`. If you use another IDE (for example Emacs or
#'   Visual Studio Code), you do not need to add it to the `default.nix` file,
#'   you can simply use the version that is installed on your computer. Once you built
#'   the environment using `nix-build`, you can drop into an interactive session
#'   using `nix-shell`. See the "Building reproducible development environments with rix"
#'   vignette for detailled instructions.
#'   Packages to install from Github must be provided in a list of 4 elements:
#'   "package_name", "repo_url", "branch_name" and "commit".
#'   This argument can also be a list of lists of these 4 elements. It is also possible to install old versions
#'   of packages by specifying a version. For example, to install the latest
#'   version of `{AER}` but an old version of `{ggplot2}`, you could
#'   write: `r_pkgs = c("AER", "ggplot2@2.2.1")`. Note
#'   however that doing this could result in dependency hell, because an older
#'   version of a package might need older versions of its dependencies, but other
#'   packages might need more recent versions of the same dependencies. If instead you
#'   want to use an environment as it would have looked at the time of `{ggplot2}`'s
#'   version 2.2.1 release, then use the Nix revision closest to that date, by setting
#'   `r_ver = "3.1.0"`, which was the version of R current at the time. This
#'   ensures that Nix builds a completely coherent environment.
#'   By default, the nix shell will be configured with `"en_US.UTF-8"` for the
#'   relevant locale variables (`LANG`, `LC_ALL`, `LC_TIME`, `LC_MONETARY`,
#'   `LC_PAPER`, `LC_MEASUREMENT`). This is done to ensure locale
#'   reproducibility by default in Nix environments created with `rix()`.
#'   If there are good reasons to not stick to the default, you can set your
#'   preferred locale variables via 
#'   `options(rix.nix_locale_variables = list(LANG = "de_CH.UTF-8", <...>)`
#'   and the aforementioned locale variable names. However, you should use 
#'   UTF-8 locales since we import the `glibcLocalesUtf8` set only, to not 
#'   download the full set of locales and thereby keep the size reasonably
#'   small.
#' @export
rix <- function(r_ver = "latest",
                r_pkgs = NULL,
                system_pkgs = NULL,
                git_pkgs = NULL,
                tex_pkgs = NULL,
                ide = "other",
                project_path = ".",
                overwrite = FALSE,
                print = FALSE,
                shell_hook = "R --vanilla"){

  stopifnot("'ide' has to be one of 'other', 'rstudio' or 'code'" = (ide %in% c("other", "rstudio", "code")))

  project_path <- if(project_path == "."){
     "default.nix"
  } else {
    paste0(project_path, "/default.nix")
  }

  # Generate the correct text for the header depending on wether
  # an R version or a Nix revision is supplied to `r_ver`
  if(nchar(r_ver) > 20){
    r_ver_text <- paste0("as it was as of nixpkgs revision: ", r_ver)
  } else {
    r_ver_text <- paste0("version ", r_ver)
  }

  # Find the Nix revision to use
  nix_revision <- find_rev(r_ver)

  project_path <- file.path(project_path)

  rix_call <- match.call()

  generate_rix_call <- function(rix_call, nix_revision){

    rix_call$r_ver <- nix_revision

    rix_call <- paste0("# >", deparse1(rix_call))

    gsub(",", ",\n#  >", rix_call)
  }

  # Get the rix version
  rix_version <- utils::packageVersion("rix")

  generate_header <- function(rix_version,
                              nix_revision,
                              r_ver_text,
                              rix_call){

    sprintf('# This file was generated by the {rix} R package v%s on %s
# with following call:
%s
# It uses nixpkgs\' revision %s for reproducibility purposes
# which will install R %s
# Report any issues to https://github.com/b-rodrigues/rix
let
 pkgs = import (fetchTarball "https://github.com/NixOS/nixpkgs/archive/%s.tar.gz") {};
',
  rix_version,
  Sys.Date(),
  generate_rix_call(rix_call, nix_revision),
  nix_revision,
  r_ver_text,
  nix_revision
  )
 }

  # Now we need to generate all the different sets of packages
  # to install. Let's start by the CRAN packages, current
  # and archived. The function below builds the strings.
  get_rPackages <- function(r_pkgs){

    # in case users pass something like c("dplyr", "tidyr@1.0.0")
    # r_pkgs will be "dplyr" only
    # and "tidyr@1.0.0" needs to be handled by fetchzips
    r_and_archive_pkgs <- detect_versions(r_pkgs)

    # overwrite r_pkgs
    r_pkgs <- r_and_archive_pkgs$cran_packages

    # get archive_pkgs
    archive_pkgs <- r_and_archive_pkgs$archive_packages

    r_pkgs <- if(ide == "code"){
                c(r_pkgs, "languageserver")
              } else {
                r_pkgs
              }

    rPackages <- paste(r_pkgs, collapse = ' ')

    rPackages <- gsub('\\.', '_', rPackages)

    list("rPackages" = rPackages,
         "archive_pkgs" = archive_pkgs)

  }

  # Get the two lists. One list is current CRAN packages
  # the other is archived CRAN packages.
  cran_pkgs <- get_rPackages(r_pkgs)

  # we need to know if the user wants R packages

  flag_rpkgs <- if(is.null(cran_pkgs$rPackages) | cran_pkgs$rPackages == ""){
                  ""
                } else {
                  "rpkgs"
                }

  # generate_* function generate the actual Nix code
  generate_rpkgs <- function(rPackages) {
    if (flag_rpkgs == ""){
      NULL
    } else {
      sprintf('rpkgs = builtins.attrValues {
  inherit (pkgs.rPackages) %s;
};
',
rPackages)
    }
  }

  # Texlive packages
  generate_tex_pkgs <- function(tex_pkgs) {
    if (!is.null(tex_pkgs)) {
      
      tex_pkgs <- paste(tex_pkgs, collapse = ' ')

    sprintf('tex = (pkgs.texlive.combine {
  inherit (pkgs.texlive) scheme-small %s;
});
',
tex_pkgs)
    }
  }

  flag_tex_pkgs <- if(is.null(tex_pkgs)){
                     ""
                   } else {
                     "tex"
                   }

  # system packages
  get_system_pkgs <- function(system_pkgs){
    paste(system_pkgs, collapse = ' ')
  }

  flag_git_archive <- if(!is.null(cran_pkgs$archive) | !is.null(git_pkgs)){
                        "git_archive_pkgs"
                      } else {
                        ""
                      }

  generate_git_archived_packages <- function(git_pkgs, archive_pkgs){
    if(flag_git_archive == ""){
      NULL
    } else {
    sprintf('git_archive_pkgs = [%s];\n',
            fetchpkgs(git_pkgs, archive_pkgs)
            )
    }
  }


  # `R` needs to be added. If we were using the rWrapper
  # this wouldn't be needed, but we're not so we need
  # to add it.
  generate_system_pkgs <- function(system_pkgs){
    sprintf('system_packages = builtins.attrValues {
  inherit (pkgs) R glibcLocalesUtf8 %s;
};
',
get_system_pkgs(system_pkgs))
  }
  
  generate_locale_variables <- function() {
    locale_defaults <- list(
      LANG = "en_US.UTF-8",
      LC_ALL = "en_US.UTF-8",
      LC_TIME = "en_US.UTF-8",
      LC_MONETARY = "en_US.UTF-8",
      LC_PAPER = "en_US.UTF-8",
      LC_MEASUREMENT = "en_US.UTF-8"
    )
    locale_variables <- getOption(
      "rix.nix_locale_variables",
      default = locale_defaults
    )
    valid_vars <- all(names(locale_variables) %in% names(locale_defaults))
    if (!isTRUE(valid_vars)) {
      stop("`options(rix.nix_locale_variables = list())` ",
        "only allows the following element names (locale variables):\n",
        paste(names(locale_defaults), collapse = "; "),
        call. = FALSE)
    }
    locale_vars <- paste(
      Map(function(x, nm) paste0(nm, ' = ', '"', x, '"'),
        nm = names(locale_variables), x = locale_variables),
      collapse = ";\n    "
    )
    paste0(locale_vars, ";\n")
  }

  generate_rstudio_pkgs <- function(ide, flag_git_archive, flag_rpkgs){
    if(ide == "rstudio"){
      sprintf('rstudio_pkgs = pkgs.rstudioWrapper.override {
  packages = [ %s %s ];
};
',
flag_git_archive,
flag_rpkgs
)
    } else {
      NULL
    }
  }

  flag_rstudio <- if (ide == "rstudio") "rstudio_pkgs" else  ""

  shell_hook <- if (!is.null(shell_hook) && nzchar(shell_hook)) {
    paste0('shellHook = "', shell_hook, '";')
  } else {''}

  # Generate the shell
  generate_shell <- function(flag_git_archive,
                             flag_rpkgs){
    sprintf('in
  pkgs.mkShell {
    %s
    %s
    buildInputs = [ %s %s %s system_packages %s ];
      %s
  }',
  generate_locale_archive(detect_os()),
  generate_locale_variables(),
  flag_git_archive,
  flag_rpkgs,
  flag_tex_pkgs,
  flag_rstudio,
  shell_hook
  )

  }

  # Generate default.nix file
  default.nix <- paste(
    generate_header(rix_version,
                    nix_revision,
                    r_ver_text,
                    rix_call),
    generate_rpkgs(cran_pkgs$rPackages),
    generate_git_archived_packages(git_pkgs, cran_pkgs$archive_pkgs),
    generate_tex_pkgs(tex_pkgs),
    generate_system_pkgs(system_pkgs),
    generate_rstudio_pkgs(ide, flag_git_archive, flag_rpkgs),
    generate_shell(flag_git_archive, flag_rpkgs),
    collapse = "\n"
    )

  default.nix <- readLines(textConnection(default.nix))

  if(print){
    cat(default.nix, sep = "\n")
  }

  if(!file.exists(project_path) || overwrite){
    writeLines(default.nix, project_path)
  } else {
    stop(paste0("File exists at ", project_path, ". Set `overwrite == TRUE` to overwrite."))
  }



}



#' @noRd
create_default_nix <- function(path = file.path("inst", "extdata",
                                 "default.nix")) {
  if (!dir.exists(dirname(path))) {
    stop("Path", path, " does not exist.")
  }
  
  rix(
    r_ver = "latest",
    r_pkgs = NULL,
    system_pkgs = NULL,
    git_pkgs = list(
      list(
        package_name = "rix",
        repo_url = "https://github.com/b-rodrigues/rix",
        branch_name = "master",
        commit = "a7b1659a5676ba34dfb68009d1993fc53431a4e3"
    )
    ),
    ide = "other",
    project_path = dirname(path),
    overwrite = TRUE,
    shell_hook = "R --vanilla"
  )
}

#' Invoke shell command `nix-build` from an R session
#' @param project_path Path to the folder where the `default.nix` file resides. 
#' The default is `"."`, which is the working directory in the current R
#' session.
#' @param exec_mode Either `"blocking"` (default) or `"non-blocking`. This
#' will either block the R session while the `nix-build` shell command is
#' executed, or run `nix-build` in the background ("non-blocking").
#' @return integer of the process ID (PID) of `nix-build` shell command
#' launched, if `nix_build()` call is assigned to an R object. Otherwise, it 
#' will be returned invisibly.
#' @details The `nix-build` command line interface has more arguments. We will
#' probably not support all of them in this R wrapper, but currently we have
#' support for the following `nix-build` flags:
#' - `--max-jobs`: Maximum number of build jobs done in parallel by Nix.
#'   According to the official docs of Nix, it defaults to `1`, which is one
#'   core. This option can be useful for shared memory multiprocessing or
#'   systems with high I/O latency. To set `--max-jobs` used, you can declare
#'   with `options(rix.nix_build_max_jobs = <integer>)`. Once you call
#'   `nix_build()` the flag will be propagated to the call of `nix-build`.
#' @export
nix_build <- function(project_path = ".",
                      exec_mode = c("blocking", "non-blocking")) {
  has_nix_build <- nix_build_installed() # TRUE if yes, FALSE if no
  nix_file <- file.path(project_path, "default.nix")
  
  stopifnot(
    "`project_path` must be character of length 1." =
      is.character(project_path) && length(project_path) == 1L,
    "`project_path` has no `default.nix` file. Use one that contains `default.nix`" =
      file.exists(nix_file),
    "`nix-build` not available. To install, we suggest you follow https://zero-to-nix.com/start/install ." =
      isTRUE(has_nix_build)
  )
  exec_mode <- match.arg(exec_mode)
  
  max_jobs <- getOption("rix.nix_build_max_jobs", default = 1L)
  stopifnot("option `rix.nix_build_max_jobs` is not integerish" =
    is_integerish(max_jobs))
  max_jobs <- as.integer(max_jobs)
  
  if (max_jobs == 1L) {
    cmd <- c("nix-build", nix_file)
  } else {
    cmd <- c("nix-build", "--max-jobs", as.character(max_jobs), nix_file)
  }
  
  cat(paste0("Launching `", paste0(cmd, collapse = " "), "`", " in ",
    exec_mode, " mode\n"))
  
  proc <- switch(exec_mode,
    "blocking" = sys::exec_internal(cmd = cmd),
    "non-blocking" = sys::exec_background(cmd = cmd),
    stop('invalid `exec_mode`. Either use "blocking" or "non-blocking"')
  )
  
  if (exec_mode == "non-blocking") {
    poll_sys_proc_nonblocking(cmd, proc, what = "nix-build")
  } else if (exec_mode == "blocking") {
    poll_sys_proc_blocking(cmd, proc, what = "nix-build")
  }
  
  # todo (?): clean zombies for background/non-blocking mode
  
  return(invisible(proc))
}

#' @noRd
poll_sys_proc_blocking <- function(cmd, proc,
                                   what = c("nix-build", "expr")) {
  what <- match.arg(what)
  status <- proc$status
  if (status == 0L) {
    cat(paste0("\n==> ", sys::as_text(proc$stdout)))
    cat(paste0("\n==> `", what, "` succeeded!"))
  } else {
    msg <- nix_build_exit_msg()
    cat(paste0("`", cmd, "`", " failed with ", msg))
  }
}

#' @noRd
poll_sys_proc_nonblocking <- function(cmd, proc, 
                                      what = c("nix-build", "expr")) {
  what <- match.arg(what)
  cat(paste0("\n==> Process ID (PID) is ", proc, "."))
  cat("\n==> Receiving stdout and stderr streams...\n")
  status <- sys::exec_status(proc, wait = TRUE)
  if (status == 0L) {
    cat(paste0("\n==> `", what, "` succeeded!"))
  }
}

#' @noRd
is_integerish <- function(x, tol = .Machine$double.eps^0.5) {
  return(abs(x - round(x)) < tol)
}

#' @noRd
nix_build_installed <- function() {
  exit_code <- system2("command", "-v", "nix-build")
  if (exit_code == 0L) {
    return(invisible(TRUE))
  } else {
    return(invisible(FALSE))
  }
}

#' @noRd
nix_build_exit_msg <- function(x) {
  x_char <- as.character(x)
  
  err_msg <- switch(
    x_char,
    "100" = "generic build failure (100).",
    "101" = "build timeout (101).",
    "102" = "hash mismatch (102).",
    "104" = "not deterministic (104).",
    stop(paste0("general exit code ", x_char, "."))
  )
  
  return(err_msg)
}


#' Evaluate expression in R or default shell
#'
#' @param expr Single R function or call, shell command, or list of them.
#' R expression 
#' @param program String stating where to evaluate the expression. Either `"R"`,
#' the default, or `"shell"`. `where = "R"` will evaluate the expression via
#' `RScript` and `where = "shell"` will run in the standard shell.
#' @inheritParams nix_build
#' @return
#' @importFrom codetools findGlobals checkUsage
#' @export
with_nix <- function(expr,
                     program = c("R", "shell"),
                     exec_mode = c("blocking", "non-blocking"),
                     project_path = ".") {
  has_nix_shell <- nix_shell_installed() # TRUE if yes, FALSE if no
  nix_file <- file.path(project_path, "default.nix")
  
  stopifnot(
    "`project_path` must be character of length 1." =
      is.character(project_path) && length(project_path) == 1L,
    "`project_path` has no `default.nix` file. Use one that contains `default.nix`" =
      file.exists(nix_file),
    "`nix-shell` not available. To install, we suggest you follow https://zero-to-nix.com/start/install ." =
      isTRUE(has_nix_shell),
    "`expr` needs to be a call or function" = is.function(expr) || is.call(expr)
  )
  program <- match.arg(program)
  exec_mode <- match.arg(exec_mode)
  
  # get the function arguments as a pairlist;
  # save formal arguments of pairlist via `tag = value`; e.g., if we have a
  # `expr = function(p = p_root) dir(path = p)`, the input object
  # to be serialized will be serialized under `"p.Rds"`  in a tmp dir, and
  # will contain object `p_root`, which is defined in the global environment
  # and bound to `"."` (project root)
  args <- as.list(formals(expr))

  temp_dir <- tempdir()
  
  # 1) save all function args onto a temporary folder each with
  # `<tag.Rds>` and `value` as serialized objects from RAM
  serialize_args(args, temp_dir)

  # if necessary, run a `nix-build` (eventually check artefacts linked to nix
  # store) to make sure nix-shell corresponds to the build
  
  # 2) deserialize formals in nix session
  
  # 3) run expression in nix session using formals/input args;
  #    mostly metaprogramming
  
  # 4) serialize resulted output from evaluating function in `expr`
  
  # 5) deserialize final output of `expr` evaluated in nix-shell
  #    into host R session
  
  # cast list of symbols/names and calls to list of strings; this is to prepare
  # deparsed version (string) of deserializing arguments from disk;
  # elements of args for now should be of type "symbol" or "language"
  args_vec <- vapply(args, deparse, FUN.VALUE = character(1L))

  r_version_file <- file.path(temp_dir, "nix-r-version.txt")
  rnix_file <- file.path(temp_dir, "with_nix_r.R")
  
  # todo in `rnix_deparsed`:
  # => locate all global variables used by function
  # https://github.com/cran/codetools/blob/master/R/codetools.R
  # http://adv-r.had.co.nz/Expressions.html#ast-funs
  
  cat("* checking code in `expr` for potential problems:\n",
   "`codetools::checkUsage(fun = expr)`\n")
  codetools::checkUsage(fun = expr)
  cat("\n")
  
  globals_expr <- codetools::findGlobals(fun = expr)
  
  # check if is function when global in "R_GlobalEnv", otherwise throw
  # an informative message if "". specifically attach packages for "package:..."
  # entries in Nix R session; if globals of `expr` are functions, again 
  # recursively deparse and assign functions in nix R script. Warn if objects
  # are not defined in function environment/provided as args to function 
  # in `expr`
  
  # extra_pkgs_call1 <- get_expr_extra_pkgs(globals_expr)
  envs_check <- lapply(globals_expr, where)
  names(envs_check) <- globals_expr
  
  vec_envs_check <- vapply(envs_check, environmentName, character(1L))
  # directly remove formals
  vec_envs_check <- vec_envs_check[!names(vec_envs_check) %in% args_vec]
  globs_pkg <- grep("^package:", vec_envs_check, value = TRUE)
  globs_base <- grep("^base$", vec_envs_check, value = TRUE)
  globs_globalenv <- grep("^R_GlobalEnv$", vec_envs_check, value = TRUE)
  globs_empty <- vec_envs_check[!nzchar(vec_envs_check)]
  globs_other <- vec_envs_check[!names(vec_envs_check) %in% 
    names(c(globs_pkg, globs_base, globs_globalenv, globs_empty))]
  if (length(globs_other) == 0L) {
    globs_other <- NULL
  }
  
  default_pkgnames <- paste0("package:", getOption("defaultPackages"))
  
  pkgenvs_attached <- setdiff(globs_pkg, c(default_pkgnames, "base"))
  
  if (!length(pkgenvs_attached) == 0L) {
    pkgs_to_attach <- gsub("^package:", "", pkgenvs_attached)
  } else {
    pkgs_to_attach <- NULL
  }
  
  # check objects in global environment that are functions, to get the
  # function call stack produced when evaluating; this way we can get
  # downstream functions we need to export
  is_globalenv_funs <- vapply(
    names(globs_globalenv), function(x) is.function(get(x)),
    FUN.VALUE = logical(1L)
  )
  globs_globalenv_fun <- globs_globalenv[is_globalenv_funs]
  globs_globalenv_other <- globs_globalenv[!is_globalenv_funs]
  
  # now find all recursive functions in the call stack
  # find_fstack() does not work here
  
  # main code to be run in nix R session
  rnix_deparsed <- get_rnix_deparsed(
    expr, program, args_vec, temp_dir, rnix_file
  )
  writeLines(text = rnix_deparsed, file(rnix_file))
  
  cat(paste0("==> Running deparsed expression via `nix-shell`", " in ",
    exec_mode, " mode:\n\n",
    paste0(rnix_deparsed, collapse = " ")))
  
  # command to run deparsed R expression via nix-shell
  cmd_rnix_deparsed <- c(
    file.path(project_path, "default.nix"),
    "--pure",
    "--run",
    sprintf(
      "Rscript --vanilla %s",
      rnix_file
    )
  )
  
  proc <- switch(exec_mode,
    "blocking" = sys::exec_internal(cmd = "nix-shell", cmd_rnix_deparsed),
    "non-blocking" = sys::exec_background(cmd = "nix-shell", cmd_rnix_deparsed),
    stop('invalid `exec_mode`. Either use "blocking" or "non-blocking"')
  )
  
  if (exec_mode == "non-blocking") {
    poll_sys_proc_nonblocking(cmd = cmd_rnix_deparsed, proc, what = "expr")
  } else if (exec_mode == "blocking") {
    poll_sys_proc_blocking(cmd = cmd_rnix_deparsed, proc, what = "expr")
  }
  
  on.exit(close(file(rnix_file)))
  
  return(invisible(proc))
}


serialize_args <- function(args, temp_dir) {
  invisible({
      Map(
        function(obj, temp_dir, nm) {
          saveRDS(
            object = eval(expr = obj, envir = parent.frame()),
            file = file.path(temp_dir, paste0(nm, ".Rds"))
          )
        },
        obj = args,
        temp_dir = temp_dir,
        nm = names(args)
      )
    })
}

# to determine which extra packages to load in Nix R prior evaluating `expr`
get_expr_extra_pkgs <- function(globals_expr) {
  envs_check <- lapply(globals_expr, where)
  names_envs_check <- vapply(envs_check, environmentName, character(1L))
  
  default_pkgnames <- paste0("package:", getOption("defaultPackages"))
  pkgenvs_attached <- setdiff(
     grep("^package:", names_envs_check, value = TRUE), 
    c(default_pkgnames, "base")
  )
  if (!length(pkgenvs_attached) == 0L) {
    pkgs_to_attach <- gsub("^package:", "", pkgenvs_attached)
    return(pkgs_to_attach)
  } else {
    return(NULL)
  }
}

is_empty <- function(x) identical(x, emptyenv())


where <- function(name, env = parent.frame()) {
  while(!is_empty(env)) {
    if (exists(name, envir = env, inherits = FALSE)) {
      return(env)
    }
    # inspect parent
    env <- parent.env(env)
  }
}

get_rnix_deparsed <- function(expr,
                              program,
                              args_vec,
                              temp_dir,
                              rnix_file) {
  switch(program,
  # do 2), 3), 4) in nix-shell-R session (check how to deal with shellHook)
    "R" = sprintf(
'# -----------------------------------------------------------------------------
cat("\n* wrote R script evaluated via `Rscript` in `nix-shell`:", \"%s\")
temp_dir <- \"%s\"
r_version_num <- paste0(R.version$major, ".", R.version$minor)
cat("\n* using Nix with R version", r_version_num, "\n")
# assign `args_vec` as in c(...) form.
args_vec <- %s
# deserialize arguments from disk
%s
# deparse and run function given in `expr` arg
%s
# execute function call in `expr` with list of correct args
lst <- as.list(args_vec)
names(lst) <- args_vec
lst <- lapply(lst, as.name)
nix_out <- do.call(run_expr, lst)
cat(paste("\n* called `expr` with args", args_vec)) 
cat("\n* the following objects are in the global environment:\n")
cat(ls())
cat("\n* `sessionInfo()` output:\n")
capture.output(sessionInfo())
# ------------------------------------------------------------------------------
\n',
    rnix_file,
    temp_dir,
    with_assign_args_vec(args_vec),
    with_deserialize_args_deparse(args_vec, temp_dir), # step 2
    with_expr_deparse(expr)
    ),
    "shell" = expr, # this has to be properly composed/decomposed
    stop('invalid `where` to evaluate `expr`. Either use "R" or "shell".')
  )
}

# https://github.com/cran/codetools/blob/master/R/codetools.R
# finding global variables

# reconstruct argument vector (character) in Nix R
with_assign_args_vec <- function(args_vec) {
  vec_nms <- vapply(
    names(args_vec), function(x) paste0('"', x, '"'), FUN.VALUE = character(1L)
  )
  paste0("c(", paste0(vec_nms, collapse = ", "), ")")
}

# deparsing code that reads args from disk
with_deserialize_args_deparse <- function(args_vec, temp_dir) {
    deparse_chr1(
      expr = quote(for (i in seq_len(length(args_vec))) {
        nm <- args_vec[i]
        obj <- args_vec[i]
        assign(
          x = nm,
          value = readRDS(file = file.path(
          temp_dir, paste0(obj, ".Rds"))
        ))
        cat(paste0("* reading ", obj, ".Rds"))
      }), 
      collapse = "\n"
    )
}

# this is what `deparse1()` does, however, it is only since 4.0.0
deparse_chr1 <- function(expr, width.cutoff = 500L, collapse = " ", ...) {
  paste(deparse(expr, width.cutoff, ...), collapse = collapse)
}

with_expr_deparse <- function(expr) {
  sprintf(
    'run_expr <- %s\n',
    deparse_chr1(expr = expr, collapse = "\n")
  )
}

#' @noRd
nix_shell_installed <- function() {
  exit_code <- system2("command", "-v", "nix-shell")
  if (exit_code == 0L) {
    return(invisible(TRUE))
  } else {
    return(invisible(FALSE))
  }
}

create_shell_nix <- function(path = file.path("inst", "extdata", 
                              "with_nix", "default.nix")) {
  if (!dir.exists(dirname(path))) {
    dir.create(dirname(path), recursive = TRUE)
  }
  
  rix(
    r_ver = "latest",
    r_pkgs = NULL,
    system_pkgs = NULL,
    git_pkgs = NULL,
    ide = "other",
    project_path = dirname(path),
    overwrite = TRUE,
    shell_hook = NULL
  )
}
