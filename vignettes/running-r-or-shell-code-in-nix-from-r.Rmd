---
title: "Running R or shell code in Nix from R"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{running-r-or-shell-code-in-nix-from-r}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(rix)
```

<!-- WARNING - This vignette is generated by {fusen} from dev/run_code_in_nix_from_r.Rmd: do not edit by hand -->

Adhering to sound versioning practices is crucial for ensuring the reproducibility of software. Despite the expertise in software engineering, the ever-growing complexity and continuous development of new, potentially disruptive features present significant challenges in maintaining code functionality over time. This pertains not only to backward compatibility but also to future-proofing. When code handles critical production loads and relies on numerous external software libraries, it's likely that these dependencies will evolve. While infrastructure-as-code and other DevOps principles shine in addressing these challenges, they may appear less approachable and more labor-intensive for the average R developer.

Are you ready to test your custom R functions and system commands in a a different environment with isolated software builds that are both pure at build and at runtime, without leaving the R console? Let's introduce `with_nix()`. `with_nix()` will evaluate custom R code or shell commands with command line interfaces provided by Nixpkgs in a Nix environment, and thereby bring the read-eval-print-loop feeling.

